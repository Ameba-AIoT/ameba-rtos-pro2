 component/example/fatfs/readme.TXT                 | 145 +++++----
 .../kvs_producer_mmf/example_kvs_producer_mmf.c    |   2 +-
 .../example_kvs_producer_mmf_video_switch.c        |   2 +-
 .../example/kvs_webrtc_mmf/module_kvs_webrtc.c     |   1 +
 component/example/littlefs/app_example.c           |  11 -
 component/example/littlefs/example_littlefs.c      | 354 ---------------------
 component/example/littlefs/example_littlefs.h      |   7 -
 component/example/littlefs/littlefs.cmake          |  22 --
 component/example/littlefs/readme.txt              |  10 -
 component/example/media_fmp4/readme.txt            |   2 +-
 component/example/qr_code_scanner/readme.txt       |  18 +-
 component/example/sqlite/readme.txt                |   8 +-
 component/example/ssl_download/readme.txt          |  49 +--
 .../wifi_roaming_plus/example_wifi_roaming_plus.c  |  15 +-
 component/example/wifi_roaming_plus/readme.txt     |   3 +-
 component/file_system/ftl_common/ftl_nand_api.c    |   1 +
 component/file_system/fwfs/fwfs.c                  |   6 +-
 component/media/mmfv2/module_video.c               |  30 +-
 .../GCC-RELEASE/application/output/libmmf.a        | Bin 399482 -> 400214 bytes
 .../GCC-RELEASE/application/output/libwlan.a       | Bin 18896274 -> 18909948 bytes
 .../mmf2_video_example_fd_lm_mfn_sim_rtsp_init.c   |   4 +-
 ...f2_video_example_joint_test_rtsp_mp4_init_fcs.c |  12 +-
 ..._video_example_joint_test_vipnn_rtsp_mp4_init.c |  74 ++++-
 .../mmf2_video_example_v3_init.c                   |   7 +-
 24 files changed, 243 insertions(+), 540 deletions(-)

diff --git a/component/example/fatfs/readme.TXT b/component/example/fatfs/readme.TXT
index c89a85a4..f0bab93a 100644
--- a/component/example/fatfs/readme.TXT
+++ b/component/example/fatfs/readme.TXT
@@ -1,69 +1,78 @@
-This example is used to read/write on various storage devices like SD card, USB, flash memory using FAT Filesystem
-
-Please follow the instructions for various options
-
-
-	1. Set the parameter CONFIG_EXAMPLE_FATFS to 1 in platform_opts.h file
-
-	2. To read and write on SD card, set the parameters as below
-
-		--> FATFS_DISK_SD to 1 in platform_opts.h under CONFIG_EXAMPLE_FATFS and  FATFS_DISK_USB & FATFS_DISK_FLASH to 0
-		--> _MAX_SS to 512  for SD card in ffconf.h to define the maximum sector size supported
-		--> _USE_MKFS to 1 in ffconf.h
-		--> For Ameba-Smart, r0.14b is used, set FF_USE_LFN to 3
-
-	3. To read and write on EMMC card, set the parameters as below
-
-		--> FATFS_DISK_SD to 1 in platform_opts.h under CONFIG_EXAMPLE_FATFS and  FATFS_DISK_USB & FATFS_DISK_FLASH to 0
-		--> _MAX_SS to 512  for EMMC card in ffconf.h to define the maximum sector size supported
-		--> _USE_MKFS to 1 in ffconf.h 
-		--> For Ameba-D and Ameba-Smart, micro SDIO in ameba_sd.h change from SD to EMMC
-		--> For Ameba-Smart, r0.14b is used, set FF_USE_LFN to 3
-
-	4. To read and write on USB, set the parameters as below [!! Only supports Ameba-1 !!]
-
-		--> FATFS_DISK_USB to 1 in platform_opts.h under CONFIG_EXAMPLE_FATFS and  FATFS_DISK_SD & FATFS_DISK_FLASH to 0
-		--> _MAX_SS to 512  for USB in ffconf.h to define the maximum sector size supported
-		--> _USE_MKFS to 0 in ffconf.h  
-
-	5. To read and write on Flash, set the parameters as below
-
-		--> FATFS_DISK_FLASH to 1 in platform_opts.h under CONFIG_EXAMPLE_FATFS and FATFS_DISK_USB & FATFS_DISK_SD to 0
-		--> _MAX_SS to 4096 for flash in ffconf.h to define the maximum sector size supported
-		--> _USE_MKFS to 1 in ffconf.h to enable f_mkfs() function which creates FATFS volume on Flash
-		--> 512 KB of on-board Ameba flash memory with the starting adddress of #define FLASH_APP_BASE  0x180000 is used for this example, refer flash_fatfs.c
-			-> Change the FLASH_APP_BASE (starting address) according to your requirements
-		--> The stack size of the example needs to be at least 4096
-     
-	6. To test dual FAT filesystem function, set the parameters as below [!! Only supports Ameba-Pro !!]
-
-		--> Set both FATFS_DISK_FLASH and FATFS_DISK_SD to 1 in platform_opts.h
-		--> Set _MAX_SS to 4096
-		--> Set _USE_MKFS to 1 in ffconf.h to enable f_mkfs() function which creates FATFS volume on Flash
-		--> Set _VOLUMES to 2 in ffconf.h				
-		--> 512 KB of on-board Ameba flash memory with the starting adddress of #define FLASH_APP_BASE  0x180000 is used for this example, refer flash_fatfs.c
-			-> Change the FLASH_APP_BASE (starting address) according to your requirements
-		--> The stack size of the example needs to be at least 4096
-
-	7. To use latest FATFS library r0.13c(released on oct 14,2018) with example_fatfs.c which supports UTF-8 encoding along with other new features, set the parameter as below
-		--> Modify #undef FATFS_R_13C macro in platform_opts.h under CONFIG_EXAMPLE_FATFS to #define FATFS_R_13C and #undef FATFS_R_10C macro
-		--> Replace existing fatfs lib with latest r0.13c lib related files to IAR project 
-		--> For further details on new features, please refer to http://elm-chan.org/fsw/ff/00index_e.html
-
-	8. To read and write on Ameba Z2 Flash	
-		--> Follow the same steps as [4] except for starting address of on-board Ameba Z2 flash memory
-		--> The user can modify the starting address on platform_opts.h according to their requirements, by default 512 KB is allocated "#define FLASH_APP_BASE (0x200000 - 0xA9000)" out of 2MB flash memory 
-		--> If it is not defined on platform_opts.h, it will take #define FLASH_APP_BASE value from flash_fatfs.c with starting address as 0x180000 
-		--> Make sure the FATFS region on Flash doesn't conflict with reserved Flash region 
-		
-	9. To read and write on Ameba-D Flash
-		--> Follow the same steps as [5]
-		
-
-        
-
-[Supported List]
-	Supported :
-	    Ameba-1, Ameba-pro, Ameba-z2，Ameba-D，Ameba-Smart
-	Source code not in project:
+This example is used to read/write on various storage devices like SD card, USB, flash memory using FAT Filesystem
+
+Please follow the instructions for various options
+
+AmebaPro2:
+	1.Use the cmake to build the example "-DEXAMPLE=fatfs".
+
+	2.You can see the (nor) flash and sd card operation from log.
+
+	3.It only support the fat32 and fatfs.
+
+	4.It don't support the usb host and nand flash.
+
+	5. To read and write on Ameba-Pro2 Flash, please note that the nand flash do not support this example
+
+Others:
+	1. Set the parameter CONFIG_EXAMPLE_FATFS to 1 in platform_opts.h file
+
+	2. To read and write on SD card, set the parameters as below
+
+		--> FATFS_DISK_SD to 1 in platform_opts.h under CONFIG_EXAMPLE_FATFS and  FATFS_DISK_USB & FATFS_DISK_FLASH to 0
+		--> _MAX_SS to 512  for SD card in ffconf.h to define the maximum sector size supported
+		--> _USE_MKFS to 1 in ffconf.h
+		--> For Ameba-Smart, r0.14b is used, set FF_USE_LFN to 3
+
+	3. To read and write on EMMC card, set the parameters as below
+
+		--> FATFS_DISK_SD to 1 in platform_opts.h under CONFIG_EXAMPLE_FATFS and  FATFS_DISK_USB & FATFS_DISK_FLASH to 0
+		--> _MAX_SS to 512  for EMMC card in ffconf.h to define the maximum sector size supported
+		--> _USE_MKFS to 1 in ffconf.h 
+		--> For Ameba-D and Ameba-Smart, micro SDIO in ameba_sd.h change from SD to EMMC
+		--> For Ameba-Smart, r0.14b is used, set FF_USE_LFN to 3
+
+	4. To read and write on USB, set the parameters as below [!! Only supports Ameba-1 !!]
+
+		--> FATFS_DISK_USB to 1 in platform_opts.h under CONFIG_EXAMPLE_FATFS and  FATFS_DISK_SD & FATFS_DISK_FLASH to 0
+		--> _MAX_SS to 512  for USB in ffconf.h to define the maximum sector size supported
+		--> _USE_MKFS to 0 in ffconf.h  
+
+	5. To read and write on (Nor) Flash, set the parameters as below
+
+		--> FATFS_DISK_FLASH to 1 in platform_opts.h under CONFIG_EXAMPLE_FATFS and FATFS_DISK_USB & FATFS_DISK_SD to 0
+		--> _MAX_SS to 4096 for flash in ffconf.h to define the maximum sector size supported
+		--> _USE_MKFS to 1 in ffconf.h to enable f_mkfs() function which creates FATFS volume on Flash
+		--> 512 KB of on-board Ameba flash memory with the starting adddress of #define FLASH_APP_BASE  0x180000 is used for this example, refer flash_fatfs.c
+			-> Change the FLASH_APP_BASE (starting address) according to your requirements
+		--> The stack size of the example needs to be at least 4096
+     
+	6. To test dual FAT filesystem function, set the parameters as below [!! Only supports Ameba-Pro !!]
+
+		--> Set both FATFS_DISK_FLASH and FATFS_DISK_SD to 1 in platform_opts.h
+		--> Set _MAX_SS to 4096
+		--> Set _USE_MKFS to 1 in ffconf.h to enable f_mkfs() function which creates FATFS volume on Flash
+		--> Set _VOLUMES to 2 in ffconf.h				
+		--> 512 KB of on-board Ameba flash memory with the starting adddress of #define FLASH_APP_BASE  0x180000 is used for this example, refer flash_fatfs.c
+			-> Change the FLASH_APP_BASE (starting address) according to your requirements
+		--> The stack size of the example needs to be at least 4096
+
+	7. To use latest FATFS library r0.13c(released on oct 14,2018) with example_fatfs.c which supports UTF-8 encoding along with other new features, set the parameter as below
+		--> Modify #undef FATFS_R_13C macro in platform_opts.h under CONFIG_EXAMPLE_FATFS to #define FATFS_R_13C and #undef FATFS_R_10C macro
+		--> Replace existing fatfs lib with latest r0.13c lib related files to IAR project 
+		--> For further details on new features, please refer to http://elm-chan.org/fsw/ff/00index_e.html
+
+	8. To read and write on Ameba Z2 Flash	
+		--> Follow the same steps as [4] except for starting address of on-board Ameba Z2 flash memory
+		--> The user can modify the starting address on platform_opts.h according to their requirements, by default 512 KB is allocated "#define FLASH_APP_BASE (0x200000 - 0xA9000)" out of 2MB flash memory 
+		--> If it is not defined on platform_opts.h, it will take #define FLASH_APP_BASE value from flash_fatfs.c with starting address as 0x180000 
+		--> Make sure the FATFS region on Flash doesn't conflict with reserved Flash region 
+		
+	9. To read and write on Ameba-D Flash
+		--> Follow the same steps as [5]
+
+
+[Supported List]
+	Supported :
+	    Ameba-1, Ameba-pro, Ameba-z2，Ameba-D，Ameba-Smart, Ameba-pro2
+	Source code not in project:
 	    Ameba-z
\ No newline at end of file
diff --git a/component/example/kvs_producer_mmf/example_kvs_producer_mmf.c b/component/example/kvs_producer_mmf/example_kvs_producer_mmf.c
index 0d975567..defbf2a3 100644
--- a/component/example/kvs_producer_mmf/example_kvs_producer_mmf.c
+++ b/component/example/kvs_producer_mmf/example_kvs_producer_mmf.c
@@ -97,7 +97,7 @@ static audio_params_t audio_params = {
 static aac_params_t aac_params = {
 	.sample_rate = 8000,
 	.channel = 1,
-	.trans_type = AAC_TYPE_ADTS,
+	.trans_type = AAC_TYPE_RAW,  //kvs producer require aac "RAW" type
 	.object_type = AAC_AOT_LC,
 	.bitrate = 32000,
 
diff --git a/component/example/kvs_producer_mmf/example_kvs_producer_mmf_video_switch.c b/component/example/kvs_producer_mmf/example_kvs_producer_mmf_video_switch.c
index ebcf3b47..85c2c6d1 100644
--- a/component/example/kvs_producer_mmf/example_kvs_producer_mmf_video_switch.c
+++ b/component/example/kvs_producer_mmf/example_kvs_producer_mmf_video_switch.c
@@ -126,7 +126,7 @@ static audio_params_t audio_params = {
 static aac_params_t aac_params = {
 	.sample_rate = 8000,
 	.channel = 1,
-	.trans_type = AAC_TYPE_ADTS,
+	.trans_type = AAC_TYPE_RAW,  //kvs producer require aac "RAW" type
 	.object_type = AAC_AOT_LC,
 	.bitrate = 32000,
 
diff --git a/component/example/kvs_webrtc_mmf/module_kvs_webrtc.c b/component/example/kvs_webrtc_mmf/module_kvs_webrtc.c
index 09ee17cb..3406102d 100644
--- a/component/example/kvs_webrtc_mmf/module_kvs_webrtc.c
+++ b/component/example/kvs_webrtc_mmf/module_kvs_webrtc.c
@@ -248,6 +248,7 @@ int kvs_webrtc_control(void *p, int cmd, int arg)
 			printf("[KVS WebRTC module]: %s xTaskCreate(kvs_webrtc_audio_thread) failed\n\r", __FUNCTION__);
 		}
 #endif
+		ctx->mediaStop = 0;
 		break;
 	case CMD_KVS_WEBRTC_STOP:
 		quitApp(); //kvs_webrtc_main_thread will be deleted
diff --git a/component/example/littlefs/app_example.c b/component/example/littlefs/app_example.c
deleted file mode 100644
index a72c78e8..00000000
--- a/component/example/littlefs/app_example.c
+++ /dev/null
@@ -1,11 +0,0 @@
-/******************************************************************************
-*
-* Copyright(c) 2007 - 2018 Realtek Corporation. All rights reserved.
-*
-******************************************************************************/
-#include "example_littlefs.h"
-
-void app_example(void)
-{
-	example_littlefs();
-}
diff --git a/component/example/littlefs/example_littlefs.c b/component/example/littlefs/example_littlefs.c
deleted file mode 100644
index b354b610..00000000
--- a/component/example/littlefs/example_littlefs.c
+++ /dev/null
@@ -1,354 +0,0 @@
-#include <cmsis.h>
-#include "FreeRTOS.h"
-#include "task.h"
-#include "platform_opts.h"
-#include "section_config.h"
-#include "flash_api.h" // Flash interface
-#include "lfs.h"
-#include "lfs_util.h"
-#include "lfs_nor_flash_api.h"
-#include "lfs_nand_flash_api.h"
-#include "ftl_common_api.h"
-#include "lfs_reent.h"
-
-
-#define NOR_BLOCK_COUNT  100
-#define NAND_FLASH_BLOCK_COUNT 100
-
-int ftl_block_read(const struct lfs_config *c, lfs_block_t block, lfs_off_t off, void *buffer, lfs_size_t size);
-int ftl_block_prog(const struct lfs_config *c, lfs_block_t block, lfs_off_t off, const void *buffer, lfs_size_t size);
-int ftl_block_erase(const struct lfs_config *c, lfs_block_t block);
-int ftl_block_sync(const struct lfs_config *c);
-
-struct lfs_config ftl_cfg = {
-	// block device operations
-	.read  = ftl_block_read,
-	.prog  = ftl_block_prog,
-	.erase = ftl_block_erase,
-	.sync  = ftl_block_sync,
-	.lock  =  lfs_system_lock,
-	.unlock = lfs_system_unlock,
-	// block device configuration
-	.read_size = 0,
-	.prog_size = 0,
-	.block_size = 0,
-	.block_count = 0,
-	.cache_size = 0,
-	.block_cycles = 100,
-	.lookahead_size = 0
-	//.lookahead_buffer = 256,
-};
-
-int ftl_block_read(const struct lfs_config *c, lfs_block_t block, lfs_off_t off, void *buffer, lfs_size_t size)
-{
-	int ret = 0;
-	if (sys_get_boot_sel() == FTL_NAND_FLASH) {
-		ret = ftl_common_read(((NAND_APP_BASE / ftl_cfg.block_size) + block) * c->block_size + off, buffer, size);
-	} else {
-		ftl_common_read(block * c->block_size + FLASH_APP_BASE + off, buffer, size);
-	}
-	if (ret == 0) {
-		ret = LFS_ERR_OK;
-	} else {
-		ret = LFS_ERR_IO;
-	}
-	return ret;
-}
-
-int ftl_block_prog(const struct lfs_config *c, lfs_block_t block, lfs_off_t off, const void *buffer, lfs_size_t size)
-{
-	int ret = 0;
-	if (sys_get_boot_sel() == FTL_NAND_FLASH) {
-		ret = ftl_common_write(((NAND_APP_BASE / ftl_cfg.block_size) + block) * c->block_size + off, (unsigned char *)buffer, size);
-	} else {
-		ftl_common_write(block * c->block_size + FLASH_APP_BASE + off, (unsigned char *)buffer, size);
-	}
-	if (ret == 0) {
-		ret = LFS_ERR_OK;
-	} else {
-		ret = LFS_ERR_IO;
-	}
-	return ret;
-}
-int ftl_block_erase(const struct lfs_config *c, lfs_block_t block)
-{
-	int ret = 0;
-	if (sys_get_boot_sel() == FTL_NAND_FLASH) {
-		ret = ftl_common_erase(((NAND_APP_BASE / ftl_cfg.block_size) + block) * c->block_size);
-	} else {
-		ftl_common_erase(block * c->block_size + FLASH_APP_BASE);
-	}
-	if (ret == 0) {
-		ret = LFS_ERR_OK;
-	} else {
-		ret = LFS_ERR_IO;
-	}
-	return ret;
-}
-int ftl_block_sync(const struct lfs_config *c)
-{
-	return 0;
-}
-
-int _traverse_df_cb(void *p, lfs_block_t block)
-{
-	uint32_t *nb = p;
-	*nb += 1;
-	return 0;
-}
-
-int littlefs_list(lfs_t *lfs, char *path)
-{
-	lfs_dir_t dir;
-	struct lfs_info info;
-	int ret = 0;
-	char cur_path[512] = {0};
-	ret = lfs_dir_open(lfs, &dir, path);
-	if (ret == LFS_ERR_OK) {
-		sprintf(cur_path, path);
-		for (;;) {
-			ret = lfs_dir_read(lfs, &dir, &info);
-			if (ret <= 0) {
-				break;
-			}
-			if (info.name[0] == '.') {
-				continue;
-			}
-			if (info.type == LFS_TYPE_DIR) {
-				sprintf(&cur_path[strlen(path)], "/%s", info.name);
-				printf("List folder %s %d %d\r\n", info.name, info.type, info.size);
-				littlefs_list(lfs, cur_path);
-			} else {
-				printf("List file %s %s %d %d\r\n", path, info.name, info.type, info.size);
-			}
-		}
-	}
-	//Close directory
-	ret = lfs_dir_close(lfs, &dir);
-	if (ret < 0) {
-		printf("Close directory fail: %d\r\n", ret);
-	}
-	return ret;
-}
-
-
-int del_dir_littlefs(lfs_t *lfs, const char *path, int del_self)
-{
-	lfs_dir_t dir;
-	struct lfs_info info;
-	int ret = 0;
-	ret = lfs_dir_open(lfs, &dir, path);
-	char file[512] = {0};
-	if (ret == LFS_ERR_OK) {
-		for (;;) {
-			// read directory and store it in file info object
-			ret = lfs_dir_read(lfs, &dir, &info);
-			if (ret <= 0) {
-				break;
-			}
-			if (info.name[0] == '.') {
-				continue;
-			}
-
-			//printf("%s %d %d\r\n",info.name,info.type,info.size);
-			sprintf((char *)file, "%s/%s", path, info.name);
-			if (info.type == LFS_TYPE_DIR) {
-				del_dir_littlefs(lfs, file, del_self);
-			} else {
-				printf("Delete file %s type %d size %d\r\n", info.name, info.type, info.size);
-				ret = lfs_remove(lfs, file);
-			}
-		}
-	}
-
-	// close directory
-	ret = lfs_dir_close(lfs, &dir);
-
-	// delete self?
-	if (ret == LFS_ERR_OK) {
-		if (del_self == 1) {
-			ret = lfs_remove(lfs, path);
-			if (ret >= 0) {
-				printf("Delete folder %s\r\n", path);
-			}
-		}
-	}
-	return ret;
-}
-
-void example_littlefs_thread(void *param)
-{
-	lfs_t *lfs = malloc(sizeof(lfs_t));
-	lfs_file_t *file = malloc(sizeof(lfs_file_t));
-	lfs_dir_t *dir = malloc(sizeof(lfs_dir_t));
-	struct lfs_info *info = malloc(sizeof(struct lfs_info));
-	int ret = 0;
-	const char *str_content = "hello_world";
-	const char *file_name = "hello.txt";
-	const char *file_folder = "flash";
-	char r_buf[64];
-	memset(r_buf, 0, sizeof(r_buf));
-
-	int type, page_size, block_size, block_cnt = 0;
-	ftl_common_info(&type, &page_size, &block_size, &block_cnt);
-	printf("type %d page_size %d block_size %d block_cnt %d\r\n", type, page_size, block_size, block_cnt);
-
-	if (type == 0) {
-		printf("It is nor flash\r\n");
-		ftl_cfg.read_size = page_size;
-		ftl_cfg.prog_size = page_size;
-		ftl_cfg.block_size = page_size;
-		ftl_cfg.block_count = NOR_BLOCK_COUNT;//You need to setup the nor sector count
-		ftl_cfg.cache_size = page_size;
-		ftl_cfg.block_cycles = 100;
-		ftl_cfg.lookahead_size = page_size;
-	} else {
-		printf("It is nand flash\r\n");
-		//cfg = &nand_cfg;
-		ftl_cfg.read_size = page_size;
-		ftl_cfg.prog_size = page_size;
-		ftl_cfg.block_size = block_size;
-		ftl_cfg.block_count = NAND_FLASH_BLOCK_COUNT;
-		ftl_cfg.cache_size = page_size;
-		ftl_cfg.block_cycles = 100;
-		ftl_cfg.lookahead_size = page_size;
-	}
-
-	// mount the filesystem
-	ret = lfs_mount(lfs, &ftl_cfg);
-	// reformat if we can't mount the filesystem
-	// this should only happen on the first boot
-	if (ret) {
-		ret = lfs_format(lfs, &ftl_cfg);
-		if (ret) {
-			printf("lfs_format fail %d\r\n", ret);
-			goto EXIT;
-		}
-		ret = lfs_mount(lfs, &ftl_cfg);
-		if (ret < 0) {
-			printf("lfs_mount fail %d\r\n", ret);
-			goto EXIT;
-		}
-	}
-
-
-	vTaskDelay(1000);
-	del_dir_littlefs(lfs, "", 1);
-
-	ret = lfs_file_open(lfs, file, file_name, LFS_O_WRONLY | LFS_O_CREAT);
-	if (ret < 0) {
-		printf("lfs_file_open fail %d\r\n", ret);
-		goto EXIT;
-	}
-
-	ret = lfs_file_seek(lfs, file, 0, LFS_SEEK_SET);
-	if (ret < 0) {
-		printf("lfs_file_seek fail %d\r\n", ret);
-		goto EXIT;
-	}
-
-	ret = lfs_file_write(lfs, file, str_content, strlen(str_content));
-	if (ret < 0) {
-		printf("lfs_file_write fail %d\r\n", ret);
-		goto EXIT;
-	}
-
-	ret = lfs_file_close(lfs, file);
-	if (ret < 0) {
-		printf("lfs_file_close fail %d\r\n", ret);
-		goto EXIT;
-	}
-
-	ret = lfs_file_open(lfs, file, "hello.txt", LFS_O_RDONLY);
-	if (ret < 0) {
-		printf("lfs_file_open fail %d\r\n", ret);
-		goto EXIT;
-	}
-
-	ret = lfs_file_size(lfs, file);
-	if (ret < 0) {
-		printf("lfs_file_size fail %d\r\n", ret);
-		goto EXIT;
-	}
-	printf("lfs_file_size %d\r\n", ret);
-
-	ret = lfs_file_read(lfs, file, r_buf, strlen(str_content));
-	if (ret < 0) {
-		printf("lfs_file_size fail %d\r\n", ret);
-		goto EXIT;
-	}
-	printf("File content %s\r\n", r_buf);
-
-	ret = lfs_file_close(lfs, file);
-	if (ret < 0) {
-		printf("lfs_file_close fail %d\r\n", ret);
-		goto EXIT;
-	}
-
-	ret = lfs_mkdir(lfs, file_folder);
-	if (ret < 0) {
-		printf("lfs_mkdir fail %d\r\n", ret);
-		//goto EXIT;
-	}
-	/////////////////
-	char path[64] = {0};
-	sprintf(path, "%s/%s", file_folder, file_name);
-	printf("open path %s\r\n", path);
-	ret = lfs_file_open(lfs, file, path, LFS_O_WRONLY | LFS_O_CREAT);
-	printf("lfs_file_open %d\r\n", ret);
-
-	ret = lfs_file_write(lfs, file, str_content, strlen(str_content));
-	if (ret < 0) {
-		printf("lfs_file_write fail %d\r\n", ret);
-		goto EXIT;
-	}
-
-	ret = lfs_file_close(lfs, file);
-	if (ret < 0) {
-		printf("lfs_file_close fail %d\r\n", ret);
-		goto EXIT;
-	}
-	////////////////
-	char buff[256] = {0};
-	strcpy(buff, "");
-	littlefs_list(lfs, buff);
-
-	uint32_t _df_nballocatedblock = 0;
-	ret = lfs_fs_traverse(lfs, _traverse_df_cb, &_df_nballocatedblock);
-	if (ret < 0) {
-		printf("lfs_fs_traverse fail %d\r\n", ret);
-		goto EXIT;
-	}
-	uint32_t available = ftl_cfg.block_count * ftl_cfg.block_size - _df_nballocatedblock * ftl_cfg.block_size;
-	printf("Avaliable space %d %d\r\n", available, _df_nballocatedblock);
-
-	printf("lfs_fs_size %d\r\n", lfs_fs_size(lfs));
-	//
-	ret = lfs_unmount(lfs);
-	if (ret < 0) {
-		printf("lfs_fs_traverse fail %d\r\n", ret);
-		goto EXIT;
-	}
-	printf("lfs_unmount %d\r\n", ret);
-EXIT:
-	if (lfs) {
-		free(lfs);
-	}
-	if (file) {
-		free(file);
-	}
-	if (dir) {
-		free(dir);
-	}
-	if (info) {
-		free(info);
-	}
-	vTaskDelete(NULL);
-}
-
-void example_littlefs(void)
-{
-	if (xTaskCreate(example_littlefs_thread, ((const char *)"example_littlefs_thread"), 2048, NULL, tskIDLE_PRIORITY + 1, NULL) != pdPASS) {
-		printf("\n\r%s xTaskCreate(example_littlefs_thread) failed", __FUNCTION__);
-	}
-}
diff --git a/component/example/littlefs/example_littlefs.h b/component/example/littlefs/example_littlefs.h
deleted file mode 100644
index af720663..00000000
--- a/component/example/littlefs/example_littlefs.h
+++ /dev/null
@@ -1,7 +0,0 @@
-#ifndef _EXAMPLE_LITTLEFS_H
-#define _EXAMPLE_LITTLEFS_H
-
-void example_littlefs(void);
-
-#endif /* _EXAMPLE_FATFS_H */
-
diff --git a/component/example/littlefs/littlefs.cmake b/component/example/littlefs/littlefs.cmake
deleted file mode 100644
index 98e424e3..00000000
--- a/component/example/littlefs/littlefs.cmake
+++ /dev/null
@@ -1,22 +0,0 @@
-### add lib ###
-list(
-	APPEND app_example_lib
-)
-
-### add flags ###
-list(
-	APPEND app_example_flags
-)
-
-### add header files ###
-list (
-	APPEND app_example_inc_path
-)
-
-### add source file ###
-list(
-	APPEND app_example_sources
-	app_example.c
-	example_littlefs.c
-)
-list(TRANSFORM app_example_sources PREPEND ${CMAKE_CURRENT_LIST_DIR}/)
diff --git a/component/example/littlefs/readme.txt b/component/example/littlefs/readme.txt
deleted file mode 100644
index df9556cb..00000000
--- a/component/example/littlefs/readme.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-
-This example is for littlefs.
-It show how to use the file system to operate it.
-The flash range can modify the NOR_BLOCK_COUNT and NAND_FLASH_BLOCK_COUNT.
-The start address is located at platform_opts.h
-
-
-[Supported List]
-	Source code not in project :
-	    AmebaPro2
\ No newline at end of file
diff --git a/component/example/media_fmp4/readme.txt b/component/example/media_fmp4/readme.txt
index adf7ae24..6579c408 100644
--- a/component/example/media_fmp4/readme.txt
+++ b/component/example/media_fmp4/readme.txt
@@ -23,7 +23,7 @@ Description
 
 Setup Guide
 ~~~~~~~~~~~
-    1. Build SQLite demo
+    1. Build Fmp4 demo
     ```
     cd project/realtek_amebapro2_v0_example/GCC-RELEASE
     mkdir build
diff --git a/component/example/qr_code_scanner/readme.txt b/component/example/qr_code_scanner/readme.txt
index 48e59775..c40d5805 100644
--- a/component/example/qr_code_scanner/readme.txt
+++ b/component/example/qr_code_scanner/readme.txt
@@ -1,6 +1,16 @@
-This is example for QR code scanner.
-You can enter the QR command to scan the qrcode to connect the wifi.
+QR code scanner for wifi connection example
+Description:
+Enter the QR command to scan the qrcode of an AP to connect the wifi.
+
+Configuration:
+	1. Use "-DEXAMPLE=qr_code_scanner" to generate Make file
+	2. Build and flash the binary to test
+
+Execution:
+    1. Prepare an AP with QR code or open the cellphone AP mode QR code
+    2. enter QR and let AmebaPro2 sensor scan the QR code
+    3. User will see the parser "decoded QR-Code symbol " and start to connect the AP
 
 [Supported List]
-	Source code not in project :
-	    AmebaPro2
\ No newline at end of file
+	Supported :
+	    RTL8730A
\ No newline at end of file
diff --git a/component/example/sqlite/readme.txt b/component/example/sqlite/readme.txt
index 61fcb299..ba3ca973 100644
--- a/component/example/sqlite/readme.txt
+++ b/component/example/sqlite/readme.txt
@@ -22,7 +22,11 @@ Description
 
 Setup Guide
 ~~~~~~~~~~~
-    1. Build SQLite demo
+    1. If using Nand flash, please set enough flash file system space in "project/realtek_amebapro2_v0_example/inc/platform_opts.h" to run this demo
+    ```
+    #define FLASH_FILESYS_SIZE      (1*1024*1024)
+    ```
+    2. Build SQLite demo
     ```
     cd project/realtek_amebapro2_v0_example/GCC-RELEASE
     mkdir build
@@ -30,7 +34,7 @@ Setup Guide
     cmake .. -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=../toolchain.cmake -DEXAMPLE=sqlite
     make flash -j4
     ```
-    2.  Download firmware to AmebaPro2 and run
+    3.  Download firmware to AmebaPro2 and run
 
 
 Parameter Setting and Configuration
diff --git a/component/example/ssl_download/readme.txt b/component/example/ssl_download/readme.txt
index 933dddca..5294933c 100644
--- a/component/example/ssl_download/readme.txt
+++ b/component/example/ssl_download/readme.txt
@@ -1,24 +1,25 @@
-SSL DOWNLOAD EXAMPLE
-
-Description:
-Download file from Web server via https.
-
-Configuration:
-1.Modify SERVER_HOST, SERVER_PORT and RESOURCE in example_ssl_download.c based on your SSL server.
-
-2.Modify SSL_MAX_CONTENT_LEN in SSL config and configTOTAL_HEAP_SIZE in freertos config for large size file.
-	If the transmitted fils size is larger than 16kbytes, SSL_MAX_CONTENT_LEN should be set to 16384.
-	FreeRTOS heap may be increased for ssl buffer allocation.
-	(ex. If using 16kbytes * 2 for ssl input/output buffer, heap should be increased from 60kbytes to 80kbytes.)
-3.[config_rsa.h]
-	#define SSL_MAX_CONTENT_LEN            16384
-4.GCC:use CMD "make all EXAMPLE=ssl_download" to compile ssl_download example.
-
-
-Execution:
-Can make automatical Wi-Fi connection when booting by using wlan fast connect example.
-A ssl download example thread will be started automatically when booting.
-
-[Supported List]
-	Supported :
-	    RTL8730A, RTL872XE
\ No newline at end of file
+SSL DOWNLOAD EXAMPLE
+
+Description:
+Download file from Web server via https.
+
+Configuration:
+1.Modify SERVER_HOST, SERVER_PORT and RESOURCE in example_ssl_download.c based on your SSL server.
+
+2.Modify MBEDTLS_SSL_MAX_CONTENT_LEN in SSL config and configTOTAL_HEAP_SIZE in freertos config for large size file.
+	If the transmitted file size is larger than 16kbytes, MBEDTLS_SSL_MAX_CONTENT_LEN should be set to 16384.
+	FreeRTOS heap may be increased for ssl buffer allocation.
+	(ex. If using 16kbytes * 2 for ssl input/output buffer, heap should be increased from 60kbytes to 80kbytes.)
+	The definition of MBEDTLS_SSL_MAX_CONTENT_LEN
+	If use mbedtls-2.16.6, define in config_rsa.h
+	If use mbedtls-2.28.1, define in mbedtls_config.h
+4.Use -DEXAMPLE=ssl_download to generate Make file
+
+
+Execution:
+Can make automatical Wi-Fi connection when booting by using wlan fast connect example.
+A ssl download example thread will be started automatically when booting.
+
+[Supported List]
+	Supported :
+	    RTL8730A (default CONFIG_USE_MBEDTLS), RTL872XE
\ No newline at end of file
diff --git a/component/example/wifi_roaming_plus/example_wifi_roaming_plus.c b/component/example/wifi_roaming_plus/example_wifi_roaming_plus.c
index a2f4c2e3..e62047c7 100644
--- a/component/example/wifi_roaming_plus/example_wifi_roaming_plus.c
+++ b/component/example/wifi_roaming_plus/example_wifi_roaming_plus.c
@@ -121,7 +121,7 @@ enum {
 #if CONFIG_LWIP_LAYER
 extern struct netif xnetif[NET_IF_NUM];
 #endif
-static wifi_roaming_ap_t *ap_list;
+static wifi_roaming_ap_t *ap_list = NULL;
 static u8 pscan_enable = _TRUE; // if set _TRUE, please set pscan_channel_list
 static u8 pscan_channel_list[] = {1}; // set by customer
 static unsigned short ping_seq = 0;
@@ -176,6 +176,7 @@ static int wlan_fast_connect(struct wifi_roaming_data *data, u8 scan_type)
 	key_id = channel >> 28;
 	channel &= 0xff;
 	security_type = data->ap_info.security_type;
+
 	//set partial scan for entering to listen beacon quickly
 WIFI_RETRY_LOOP:
 	if (scan_type == FAST_CONNECT_SPECIFIC_CH) {
@@ -230,11 +231,13 @@ WIFI_RETRY_LOOP:
 		if ((data->ap_n < MAX_AP_NUM) && (scan_type == FAST_CONNECT_SPECIFIC_CH)) {
 			int i = 0;
 			for (i = 0; i < data->ap_n; i++) {
-				if (memcmp(ap_list->bssid, data->add_ap_info[i].ap_bssid, ETH_ALEN) == 0) {
-					offer_ip = data->add_ap_info[i].sta_ip;
-					server_ip = data->add_ap_info[i].server_ip;
-					ROAMING_DBG("\n\r Find the ehter_addr in flash() \n");
-					break;
+				if (ap_list) {
+					if (memcmp(ap_list->bssid, data->add_ap_info[i].ap_bssid, ETH_ALEN) == 0) {
+						offer_ip = data->add_ap_info[i].sta_ip;
+						server_ip = data->add_ap_info[i].server_ip;
+						ROAMING_DBG("\n\r Find the ehter_addr in flash() \n");
+						break;
+					}
 				}
 			}
 		}
diff --git a/component/example/wifi_roaming_plus/readme.txt b/component/example/wifi_roaming_plus/readme.txt
index 44922fc0..806206b8 100644
--- a/component/example/wifi_roaming_plus/readme.txt
+++ b/component/example/wifi_roaming_plus/readme.txt
@@ -36,7 +36,8 @@ Parameter Setting and Configuration
     1. Set the RSSI_SCAN_THRESHOLD and RSSI_ROAMING_THRESHOLD and FIND_BETTER_RSSI_DELTA according to the WLAN envrionment.
     2. Config MAX_CH_NUM and MAX_AP_NUM for your application usage. But with more scan MAX_CH_NUM, pre-scan time may takes longer.
     3. IF support 5G channels. enable SUPPORT_SCAN_5G_CHANNEL and set the roaming_channel_plan.
-    
+    4. The duration of this example is 85-90seconds. After 85-95 seconds, this example will stop.
+
 
 
 Result description
diff --git a/component/file_system/ftl_common/ftl_nand_api.c b/component/file_system/ftl_common/ftl_nand_api.c
index 4a79a0cf..189594b1 100644
--- a/component/file_system/ftl_common/ftl_nand_api.c
+++ b/component/file_system/ftl_common/ftl_nand_api.c
@@ -43,6 +43,7 @@ bbm_info_attr *bbm_info = NULL;
 
 int bbm_mark_bad_block(bbm_info_attr *bbm_info, int block);
 int bbm_update_table(bbm_info_attr *bbm);
+int ftl_erase_bbm_table(void);
 
 int bbm_find_table_index(bbm_info_attr *bbm)
 {
diff --git a/component/file_system/fwfs/fwfs.c b/component/file_system/fwfs/fwfs.c
index c39da503..62856ac6 100644
--- a/component/file_system/fwfs/fwfs.c
+++ b/component/file_system/fwfs/fwfs.c
@@ -361,12 +361,12 @@ void nand_pfw_init(void)
 	g_partition.dirty = 0;
 
 	// fci sanity check
-	if ((fci->page_size != 512) || (fci->page_size != 2048) || (fci->page_size != 4096) || (fci->page_size != 8192)) {
+	if ((fci->page_size != 512) && (fci->page_size != 2048) && (fci->page_size != 4096) && (fci->page_size != 8192)) {
 		fci->page_size = 2048;
 	}
 
-	if (fci->page_per_blk != 32 || fci->page_per_blk != 64 || fci->page_per_blk != 128 || fci->page_per_blk != 256) {
-		fci->page_size = 64;
+	if (fci->page_per_blk != 32 && fci->page_per_blk != 64 && fci->page_per_blk != 128 && fci->page_per_blk != 256) {
+		fci->page_per_blk = 64;
 	}
 
 	if (fci->spare_size < 32 || fci->spare_size > 224) {
diff --git a/component/media/mmfv2/module_video.c b/component/media/mmfv2/module_video.c
index 26ea52eb..e40a6ae4 100644
--- a/component/media/mmfv2/module_video.c
+++ b/component/media/mmfv2/module_video.c
@@ -86,12 +86,24 @@ int video_get_cb_fps(int chn)
 	}
 	return ch_fps[chn];
 }
-
+static int video_rate_control_check_fps(int fps)
+{
+	int isp_min_fps = 0;
+	int isp_max_fps = 0;
+	isp_get_min_fps(&isp_min_fps);
+	isp_get_max_fps(&isp_max_fps);
+	if (isp_max_fps > 0 && isp_max_fps < fps) {
+		return isp_max_fps;
+	}
+	if (isp_min_fps > 0 && isp_min_fps > fps) {
+		return isp_min_fps;
+	}
+	return fps;
+}
 void video_rate_control_process(video_ctx_t *ctx)
 {
 	int fps = 0;
 	int gop = 0;
-	int isp_min_fps = 0;
 	static int switch_fps_up[2] = {0, 0};
 	static int switch_fps_down[2] = {0, 0};
 	float mul = (float) ctx->params.gop / ctx->rate_ctrl_p.ori_framerate;
@@ -102,11 +114,7 @@ void video_rate_control_process(video_ctx_t *ctx)
 			switch_fps_down[ctx->params.stream_id]++;
 			if (switch_fps_down[ctx->params.stream_id] == RATE_CTRL_DEBOUNCE) {
 				ctx->rate_ctrl_p.fps_stage_idx++;
-				fps = ctx->rate_ctrl_p.fps_stage[ctx->rate_ctrl_p.fps_stage_idx - 1];
-				isp_get_min_fps(&isp_min_fps);
-				if (isp_min_fps > 0 && isp_min_fps < fps) {
-					fps = isp_min_fps;
-				}
+				fps = video_rate_control_check_fps(ctx->rate_ctrl_p.fps_stage[ctx->rate_ctrl_p.fps_stage_idx - 1]);
 				ctx->rate_ctrl_p.current_framerate = fps;
 				ctx->rate_ctrl_p.rate_ctrl.sampling_time = gop = fps * mul;
 				VIDEO_DBG_INFO("\r\nch = %d sample rate = %ld	maximun bitrate = %ld	fps = %d\r\n",
@@ -124,13 +132,9 @@ void video_rate_control_process(video_ctx_t *ctx)
 			if (switch_fps_up[ctx->params.stream_id] == RATE_CTRL_DEBOUNCE) {
 				ctx->rate_ctrl_p.fps_stage_idx--;
 				if (ctx->rate_ctrl_p.fps_stage_idx) {
-					fps = ctx->rate_ctrl_p.fps_stage[ctx->rate_ctrl_p.fps_stage_idx - 1];
+					fps = video_rate_control_check_fps(ctx->rate_ctrl_p.fps_stage[ctx->rate_ctrl_p.fps_stage_idx - 1]);
 				} else {
-					fps = ctx->rate_ctrl_p.ori_framerate;
-				}
-				isp_get_min_fps(&isp_min_fps);
-				if (isp_min_fps > 0 && isp_min_fps < fps) {
-					fps = isp_min_fps;
+					fps = video_rate_control_check_fps(ctx->rate_ctrl_p.ori_framerate);
 				}
 				ctx->rate_ctrl_p.current_framerate = fps;
 				ctx->rate_ctrl_p.rate_ctrl.sampling_time = gop = fps * mul;
diff --git a/project/realtek_amebapro2_v0_example/GCC-RELEASE/application/output/libmmf.a b/project/realtek_amebapro2_v0_example/GCC-RELEASE/application/output/libmmf.a
index 9618d41f..74c1df1b 100644
Binary files a/project/realtek_amebapro2_v0_example/GCC-RELEASE/application/output/libmmf.a and b/project/realtek_amebapro2_v0_example/GCC-RELEASE/application/output/libmmf.a differ
diff --git a/project/realtek_amebapro2_v0_example/GCC-RELEASE/application/output/libwlan.a b/project/realtek_amebapro2_v0_example/GCC-RELEASE/application/output/libwlan.a
index ce844b18..fd183fbe 100644
Binary files a/project/realtek_amebapro2_v0_example/GCC-RELEASE/application/output/libwlan.a and b/project/realtek_amebapro2_v0_example/GCC-RELEASE/application/output/libwlan.a differ
diff --git a/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_fd_lm_mfn_sim_rtsp_init.c b/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_fd_lm_mfn_sim_rtsp_init.c
index edfa9571..f0f77171 100644
--- a/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_fd_lm_mfn_sim_rtsp_init.c
+++ b/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_fd_lm_mfn_sim_rtsp_init.c
@@ -209,8 +209,8 @@ static void face_draw_object(void *p, void *img_param)
 				canvas_set_rect(RTSP_CHANNEL, 0, xmin, ymin, xmax, ymax, 3, COLOR_RED);
 				canvas_set_text(RTSP_CHANNEL, 0, xmin, ymin - 32, fdraw->obj_name[i], COLOR_RED);
 			} else {
-				canvas_set_rect(RTSP_CHANNEL, 0, xmin, ymin, xmax, ymax, 3, COLOR_GREEN);
-				canvas_set_text(RTSP_CHANNEL, 0, xmin, ymin - 32, fdraw->obj_name[i], COLOR_GREEN);
+				canvas_set_rect(RTSP_CHANNEL, 1, xmin, ymin, xmax, ymax, 3, COLOR_GREEN);
+				canvas_set_text(RTSP_CHANNEL, 1, xmin, ymin - 32, fdraw->obj_name[i], COLOR_GREEN);
 			}
 		}
 		if (osd_cleanup_timer) {
diff --git a/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_joint_test_rtsp_mp4_init_fcs.c b/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_joint_test_rtsp_mp4_init_fcs.c
index 7b3a679a..f2682af5 100644
--- a/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_joint_test_rtsp_mp4_init_fcs.c
+++ b/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_joint_test_rtsp_mp4_init_fcs.c
@@ -104,10 +104,10 @@ static video_boot_stream_t video_boot_stream = {
 	.video_snapshot[STREAM_V1] = 0,
 	.video_drop_frame[STREAM_V1] = 0,
 	.video_params[STREAM_V1].fcs = 1,//Enable the fcs for channel 1
-	.auto_rate_control[STREAM_V1].sampling_time = 15,
-	.auto_rate_control[STREAM_V1].maximun_bitrate = 3 * 1024 * 1024 * 1.2,
-	.auto_rate_control[STREAM_V1].minimum_bitrate = 3 * 1024 * 1024 * 0.8,
-	.auto_rate_control[STREAM_V1].target_bitrate = 3 * 1024 * 1024,
+	.auto_rate_control[STREAM_V1].sampling_time = sensor_params[USE_SENSOR].sensor_fps,
+	.auto_rate_control[STREAM_V1].maximun_bitrate = 2 * 1024 * 1024 * 1.2,
+	.auto_rate_control[STREAM_V1].minimum_bitrate = 2 * 1024 * 1024 * 0.8,
+	.auto_rate_control[STREAM_V1].target_bitrate = 2 * 1024 * 1024,
 	.video_params[STREAM_V2].stream_id = STREAM_V2,
 	.video_params[STREAM_V2].type = CODEC_H264,
 	.video_params[STREAM_V2].resolution = 0,
@@ -183,8 +183,9 @@ static video_boot_stream_t video_boot_stream = {
 	.fcs_isp_init_daynight_mode = 0,
 	.voe_heap_size = 0,
 	.voe_heap_addr = 0,
-	.isp_info.sensor_width  = sensor_params[USE_SENSOR].sensor_width,
+	.isp_info.sensor_width = sensor_params[USE_SENSOR].sensor_width,
 	.isp_info.sensor_height = sensor_params[USE_SENSOR].sensor_height,
+	.isp_info.sensor_fps = sensor_params[USE_SENSOR].sensor_fps,
 	.isp_info.md_enable = 1,
 	.isp_info.hdr_enable = 1,
 	.isp_info.osd_enable = 1,
@@ -785,6 +786,7 @@ void mmf2_video_example_joint_test_rtsp_mp4_init_fcs(void)
 			mm_module_ctrl(video_v1_ctx, CMD_VIDEO_APPLY, V1_CHANNEL);	// start channel 0
 			if (auto_rate_ctrl_en[STREAM_V1]) {
 				mm_module_ctrl(video_v1_ctx, CMD_VIDEO_SET_RATE_CONTROL, (int)&rate_ctrl_v1_params);
+				mp4_v1_params.append_header = 1;//enable appending header, since the auto rate control may update the video header
 			}
 		} else {
 			rt_printf("video open fail\n\r");
diff --git a/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_joint_test_vipnn_rtsp_mp4_init.c b/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_joint_test_vipnn_rtsp_mp4_init.c
index 5d2a8ae4..2a2e87cf 100644
--- a/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_joint_test_vipnn_rtsp_mp4_init.c
+++ b/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_joint_test_vipnn_rtsp_mp4_init.c
@@ -304,6 +304,71 @@ static void audio_params_customized_setting(void)
 #include "osd_render.h"
 #define LIMIT(x, lower, upper) if(x<lower) x=lower; else if(x>upper) x=upper;
 
+static TimerHandle_t osd_cleanup_timer = NULL;
+static void face_cleanup_callback(TimerHandle_t xTimer)
+{
+	(void)xTimer;
+	canvas_create_bitmap(RTSP_CHANNEL, 1, RTS_OSD2_BLK_FMT_1BPP);
+	canvas_create_bitmap(RTSP_CHANNEL, 2, RTS_OSD2_BLK_FMT_1BPP);
+	canvas_update(RTSP_CHANNEL, 1, 0);
+	canvas_update(RTSP_CHANNEL, 2, 1);
+}
+
+static void face_draw_object(void *p, void *img_param)
+{
+	int i = 0;
+	frc_draw_t *fdraw = (frc_draw_t *)p;
+
+	if (!p)	{
+		return;
+	}
+
+	int im_h = RTSP_HEIGHT;
+	int im_w = RTSP_WIDTH;
+
+
+	//printf("face num = %d\r\n", fdraw->obj_cnt);
+	canvas_create_bitmap(RTSP_CHANNEL, 1, RTS_OSD2_BLK_FMT_1BPP);//draw red for unknown
+	canvas_create_bitmap(RTSP_CHANNEL, 2, RTS_OSD2_BLK_FMT_1BPP);
+	if (fdraw->obj_cnt > 0) {
+		for (i = 0; i < fdraw->obj_cnt; i++) {
+			frc_bbox_t *bbox = &fdraw->bbox[i];
+			int x_offset = 0, y_offset = 0;
+			float ratio;
+			if ((float)im_w / (float)im_h > (float)fdraw->pic_width / (float)fdraw->pic_height) {
+				ratio = (float)im_h / (float)fdraw->pic_height;
+				x_offset = (im_w - (float)fdraw->pic_width * ratio) / 2;
+			} else {
+				ratio = (float)im_w / (float)fdraw->pic_width;
+				y_offset = (im_h - (float)fdraw->pic_height * ratio) / 2;
+			}
+
+			int xmin = (int)(bbox->xmin * ratio * (float)fdraw->pic_width) + x_offset;
+			int ymin = (int)(bbox->ymin * ratio * (float)fdraw->pic_height) + y_offset;
+			int xmax = (int)(bbox->xmax * ratio * (float)fdraw->pic_width) + x_offset;
+			int ymax = (int)(bbox->ymax * ratio * (float)fdraw->pic_height) + y_offset;
+			LIMIT(xmin, 0, im_w)
+			LIMIT(xmax, 0, im_w)
+			LIMIT(ymin, 0, im_h)
+			LIMIT(ymax, 0, im_h)
+			//printf("%d,c%s:%d %d %d %d\n\r", i, fdraw->obj_name[i], xmin, ymin, xmax, ymax);
+
+			if (!strcmp(fdraw->obj_name[i], "unknown")) {
+				canvas_set_rect(RTSP_CHANNEL, 1, xmin, ymin, xmax, ymax, 3, COLOR_RED);
+				canvas_set_text(RTSP_CHANNEL, 1, xmin, ymin - 40, fdraw->obj_name[i], COLOR_RED);
+			} else {
+				canvas_set_rect(RTSP_CHANNEL, 2, xmin, ymin, xmax, ymax, 3, COLOR_GREEN);
+				canvas_set_text(RTSP_CHANNEL, 2, xmin, ymin - 40, fdraw->obj_name[i], COLOR_GREEN);
+			}
+		}
+		if (osd_cleanup_timer) {
+			xTimerReset(osd_cleanup_timer, 10);
+		}
+	}
+	canvas_update(RTSP_CHANNEL, 1, 0);
+	canvas_update(RTSP_CHANNEL, 2, 1);
+}
+
 static int check_in_list(int class_indx)
 {
 	for (int i = 0; i < (sizeof(desired_class_list) / sizeof(int)); i++) {
@@ -622,8 +687,8 @@ void mmf2_video_example_joint_test_vipnn_rtsp_mp4_init(void)
 		mm_module_ctrl(facenet_ctx, CMD_VIPNN_SET_CASCADE, 2);		// this module is cascade mode
 
 		mm_module_ctrl(facenet_ctx, CMD_VIPNN_SET_OUTPUT, 1);		// output
-		mm_module_ctrl(facedet_ctx, CMD_VIPNN_SET_RES_SIZE, sizeof(face_feature_res_t));		// result size
-		mm_module_ctrl(facedet_ctx, CMD_VIPNN_SET_RES_MAX_CNT, MAX_DETECT_OBJ_NUM);		// result max coun
+		mm_module_ctrl(facenet_ctx, CMD_VIPNN_SET_RES_SIZE, sizeof(face_feature_res_t));		// result size
+		mm_module_ctrl(facenet_ctx, CMD_VIPNN_SET_RES_MAX_CNT, MAX_DETECT_OBJ_NUM);		// result max coun
 		mm_module_ctrl(facenet_ctx, MM_CMD_SET_QUEUE_LEN, 1);
 		mm_module_ctrl(facenet_ctx, MM_CMD_INIT_QUEUE_ITEMS, MMQI_FLAG_STATIC);
 
@@ -638,7 +703,7 @@ void mmf2_video_example_joint_test_vipnn_rtsp_mp4_init(void)
 	facerecog_ctx = mm_module_open(&facerecog_module);
 	if (facerecog_ctx) {
 		mm_module_ctrl(facerecog_ctx, CMD_FRC_SET_THRES100, 99);  // 99/100 = 0.99 --> set a value to get lowest FP rate
-		mm_module_ctrl(facerecog_ctx, CMD_FRC_SET_OSD_DRAW, (int)NULL);  //face_draw_object
+		mm_module_ctrl(facerecog_ctx, CMD_FRC_SET_OSD_DRAW, (int)face_draw_object);  //face_draw_object
 	} else {
 		printf("FACERECOG open fail\n\r");
 		goto mmf2_video_example_joint_test_vipnn_rtsp_mp4_fail;
@@ -845,6 +910,9 @@ void mmf2_video_example_joint_test_vipnn_rtsp_mp4_init(void)
 	int ch_width[3] = {0, RTSP_WIDTH, 0}, ch_height[3] = {0, RTSP_HEIGHT, 0};
 	osd_render_dev_init(ch_enable, char_resize_w, char_resize_h);
 	osd_render_task_start(ch_enable, ch_width, ch_height);
+#if ENABLE_NN_FACERECOG
+	osd_cleanup_timer = xTimerCreate("OSD clean timer", 1000 / portTICK_PERIOD_MS, pdTRUE, NULL, face_cleanup_callback);
+#endif
 
 	return;
 mmf2_video_example_joint_test_vipnn_rtsp_mp4_fail:
diff --git a/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_v3_init.c b/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_v3_init.c
index f469d984..af081f17 100644
--- a/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_v3_init.c
+++ b/project/realtek_amebapro2_v0_example/src/mmfv2_video_example/mmf2_video_example_v3_init.c
@@ -51,8 +51,11 @@ void mmf2_video_example_v3_init(void)
 
 	/*sensor capacity check & video parameter setting*/
 	video_v3_params.resolution = VIDEO_FHD;
-	video_v3_params.width = sensor_params[USE_SENSOR].sensor_width;
-	video_v3_params.height = sensor_params[USE_SENSOR].sensor_height;
+
+	//In RFC 2435 for rtp jpg, the width and height should be less than 2040 (8bits 255 * 8 = 2040)
+	//User could ignore this checking, if there server could support
+	video_v3_params.width = sensor_params[USE_SENSOR].sensor_width > 2040 ? 2040 : sensor_params[USE_SENSOR].sensor_width;
+	video_v3_params.height = sensor_params[USE_SENSOR].sensor_height > 2040 ? 2040 : sensor_params[USE_SENSOR].sensor_height;
 	video_v3_params.fps = V3_FPS;
 	video_v3_params.gop = V3_GOP;
 	/*rtsp parameter setting*/
